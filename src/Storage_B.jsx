/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 C:\Users\osain\Coding\Projects\3js\Sohne\Maya\scenes\Storage_B.gltf -o C:\Users\osain\Coding\Projects\3js\Sohne\src\Storage_B.jsx 
*/

import React, {
  useContext,
  useEffect,
  useMemo,
  useState,
  useRef,
  useImperativeHandle,
  forwardRef,
} from "react";
import {
  Center,
  PivotControls,
  TransformControls,
  useGLTF,
  useTexture,
} from "@react-three/drei";
import * as THREE from "three";
import { animated, useSpring } from "@react-spring/three";
import { useDrag, useGesture } from "react-use-gesture";
import {
  ExperienceContext,
  GlobalStateContext,
  StorageContext,
} from "./ExpContext";
import {
  EffectComposer,
  Outline,
  Selection,
  Select,
} from "@react-three/postprocessing";
import { KernelSize } from "postprocessing";
import { ArrowStraight } from "./ArrowStraight";
import { ArrowCurved } from "./ArrowCurved";

export const Storage_B = React.forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF("./gltf/Storage_B.gltf");
  const drawer1Ref = useRef();
  const drawer2Ref = useRef();
  const drawer3Ref = useRef();
  const door1Ref = useRef();
  const door2Ref = useRef();
  const { storageBRef, storageRotation } = useContext(StorageContext);
  const { currStorage, setobjConfig, currBaseTexture } =
    useContext(GlobalStateContext);
  const [
    aoStorageB,
    aoDoor,
    aoDrawer,
    aoDrawerBig,
    aoFrame,
    aoKnobs,
    mahoganyDoor,
    mahoganyDrawer,
    mahoganyDrawerBig,
    mahoganyFrame,
    oakDoor,
    oakDrawer,
    oakDrawerBig,
    oakFrame,
  ] = useTexture([
    "/textures/AO_Storage_B_.png",
    "/textures/AO_Storage_B_Door_1_mtl.png",
    "/textures/AO_Storage_B_Drawer_1_mtl.png",
    "/textures/AO_Storage_B_Drawer_3_mtl.png",
    "/textures/AO_Storage_B_Frame_mtl.png",
    "/textures/AO_Storage_B_Knobs_1_mtl.png",
    "/textures/Mahogany_Storage_B_Door_1_mtl.png",
    "/textures/Mahogany_Storage_B_Drawer_1_mtl.png",
    "/textures/Mahogany_Storage_B_Drawer_1_mtl.png",
    "/textures/Mahogany_Storage_B_Frame_mtl.png",
    "/textures/Oak_Storage_B_Door_1_mtl.png",
    "/textures/Oak_Storage_B_Drawer_1_mtl.png",
    "/textures/Oak_Storage_B_Drawer_3_mtl.png",
    "/textures/Oak_Storage_B_Frame_mtl.png",
  ]);
  const [hovered, setHovered] = useState({
    drawer1: false,
    drawer2: false,
    drawer3: false,
    door1: false,
    door2: false,
    frame: false,
  });
  const [clicked, setClicked] = useState({
    drawer1: false,
    drawer2: false,
    drawer3: false,
    door1: false,
    door2: false,
    frame: false,
  });

  const [spring, set] = useSpring(() => ({
    rotation: [0, 0, 0],
    config: { friction: 10 },
  }));

  const [{ x, y }, api] = useSpring(() => ({ x: 0, y: 0 }));
  const [, frameApi] = useSpring(() => ({ x: 0, y: 0 }));

  const bindStorageB = useDrag(({ down, offset: [mx] }) => {
    if (!clicked.frame) return;
    frameApi.start({
      x: down ? (storageBRef.current.rotation.y = mx * 0.01) : 0,
      immediate: down,
    });
  });

  const bindDoor1 = useDrag(({ down, offset: [mx], },) => {
    
    if ( mx > 0 || mx < -40 || !clicked.door1) return;
    api.start({
      x: down ? (door1Ref.current.rotation.y = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindDoor2 = useDrag(({ down, offset: [mx, my] }) => {
    if (mx < 0 || mx > 40 || !clicked.door2) return;

    api.start({
      x: down ? (door2Ref.current.rotation.y = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindDrawer2 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 300 || mx < 0 || !clicked.drawer2) return;
    api.start({
      x: down ? (drawer2Ref.current.position.z = mx * -0.1) : 0,
      immediate: down,
    });
  });
  const bindDrawer1 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 300 || mx < 0 || !clicked.drawer1) return;
    api.start({
      x: down ? (drawer1Ref.current.position.z = mx * -0.1) : 0,
      immediate: down,
    });
  });
  const bindDrawer3 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 300 || mx < 0 || !clicked.drawer3) return;
    api.start({
      x: down ? (drawer3Ref.current.position.z = mx * -0.1) : 0,
      immediate: down,
    });
  });

  const deSelect = () => {
    console.log("[Storage_B.jsx] deselect()");
    setClicked({
      drawer1: false,
      drawer2: false,
      drawer3: false,
      door1: false,
      door2: false,
      frame: false,
    });
    setHovered({
      drawer1: false,
      drawer2: false,
      drawer3: false,
      door1: false,
      door2: false,
      frame: false,
    });
  };

  useImperativeHandle(ref, () => {
    return { deSelect };
  });

  useEffect(() => {
    if (currStorage === "b") {
      setobjConfig({
        baseTextures: [
          "/textures/Mahogany_Storage_B_Frame_mtl.png",
          "/textures/Oak_Storage_B_Frame_mtl.png",
        ],
        cushionTextures: [],
      });
    }
  }, [currStorage]);

  aoStorageB.flipY = false;
  aoDoor.flipY = false;
  aoDrawer.flipY = false;
  aoDrawerBig.flipY = false;
  aoFrame.flipY = false;
  aoKnobs.flipY = false;
  mahoganyDoor.flipY = false;
  mahoganyDrawer.flipY = false;
  mahoganyDrawerBig.flipY = false;
  mahoganyFrame.flipY = false;
  oakDoor.flipY = false;
  oakDrawer.flipY = false;
  oakDrawerBig.flipY = false;
  oakFrame.flipY = false;

  const frameMtl = new THREE.MeshStandardMaterial({
    map: mahoganyFrame,
    // roughnessMap: Storage_C_rough_frame,
    aoMap: aoFrame,
    aoMapIntensity: 1,
    side: THREE.DoubleSide,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const drawerMtl = new THREE.MeshStandardMaterial({
    map: mahoganyDrawer,
    // roughnessMap: Storage_C_rough_frame,
    aoMap: aoDrawer,
    aoMapIntensity: 1,
    side: THREE.DoubleSide,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const drawerBigMtl = new THREE.MeshStandardMaterial({
    map: mahoganyDrawerBig,
    // roughnessMap: Storage_C_rough_frame,
    aoMap: aoDrawerBig,
    aoMapIntensity: 1,
    side: THREE.DoubleSide,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const doorMtl = new THREE.MeshStandardMaterial({
    map: mahoganyDoor,
    // roughnessMap: Storage_C_rough_frame,
    aoMap: aoDoor,
    aoMapIntensity: 1,
    side: THREE.DoubleSide,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });

  const glassMAt = new THREE.MeshPhysicalMaterial({
    transparent: true, // Enable transparency
    metalness: 0, // Metalness of the material (0 for non-metallic surfaces)
    roughness: 0.051, // Roughness of the material (0 for perfectly smooth)
    transmission: 1,
    thickness: 1,
    envMapIntensity: 0.5,
  });
  const goldMat = new THREE.MeshPhysicalMaterial({
    color: "#ffe244", // Gold color
    envMapIntensity: 1,
    metalness: 1,
    clearcoat: 1,
    clearcoatRoughness: 1,
    reflectivity: 1,
    roughness: 0.2, // Adjust the roughness for a realistic appearance
  });
  const chromeMat = new THREE.MeshPhysicalMaterial({
    color: "silver", // Gold color
    envMapIntensity: 2,
    metalness: 1,
    clearcoat: 1,
    clearcoatRoughness: 1,
    reflectivity: 1,
    roughness: 0.3,
  });
  return (
    <animated.group
      {...props}
      dispose={null}
      ref={storageBRef}
      scale={0.08}
      position={[23, 0, 16]}
      {...spring}
      {...bindStorageB()}
      rotation-y={storageRotation.rotate}
    >
      <group rotation={[-Math.PI / 2, -Math.PI / 2,  -Math.PI / 2]}>
        <Selection>
          <EffectComposer multisampling={8} autoClear={false}>
            <Outline
              blur
              kernelSize={KernelSize.VERY_SMALL}
              resolutionScale={0}
              visibleEdgeColor={
                Object.values(hovered).some((value) => value)
                  ? "white"
                  : undefined
              }
              edgeStrength={
                Object.values(clicked).some((value) => value) ? 0 : 2
              }
              width={Object.values(hovered).some((value) => value) ? 500 : 0}
            />
            <Outline
              blur
              kernelSize={KernelSize.VERY_SMALL}
              resolutionScale={0}
              visibleEdgeColor={
                Object.values(clicked).some((value) => value)
                  ? "yellow"
                  : undefined
              }
              edgeStrength={
                Object.values(clicked).some((value) => value) ? 2 : 0
              }
              width={Object.values(clicked).some((value) => value) ? 500 : 0}
            />
            <Select enabled={hovered.frame || clicked.frame}>
              <mesh
                onClick={(e) => {
                  console.log(e);
                  setClicked({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: false,
                  });
                  e.stopPropagation();
                }}
                onPointerEnter={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  e.stopPropagation();
                }}
                onPointerOver={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  e.stopPropagation();
                }}
                onPointerLeave={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: false,
                  });
                  e.stopPropagation();
                }}
                geometry={nodes.Frame.geometry}
                material={frameMtl}
              />

              <Select enabled={hovered.door1 || clicked.door1}>
                <PivotControls
                  anchor={[1, 1, 1]}
                  scale={0}
                  autoTransform={false}
                >
                  <Center
                    top
                    left
                    ref={door1Ref}
                    {...bindDoor1()}
                    position={[68, 21,-17]}
                    rotation={[0, -0.0, 0]}
                  >
                    <animated.group
                      ref={door1Ref}
                      {...bindDoor1()}
                      onClick={(e) => {
                        setClicked({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: true,
                          door2: false,
                          frame: false,
                        });
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerEnter={(e) => {
                        if (
                          clicked.door1 ||
                          Object.values(clicked).some((value) => value)
                        )
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: true,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerOver={(e) => {
                        if (
                          clicked.door1 ||
                          Object.values(clicked).some((value) => value)
                        )
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: true,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerLeave={(e) => {
                        if (Object.values(clicked).some((value) => value))
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                    >
                      <mesh
                        geometry={nodes.Handle_1.geometry}
                        material={goldMat}
                      />
                      <mesh
                        geometry={nodes.Door_1.geometry}
                        material={doorMtl}
                      />
                      <mesh
                        geometry={nodes.Glass_1.geometry}
                        material={glassMAt}
                      />
                    </animated.group>
                  </Center>
                </PivotControls>
              </Select>
              <Select enabled={hovered.door2 || clicked.door2}>
                <PivotControls
                  anchor={[-1, 1, 1]}
                  rotation={[1, 1, 1]}
                  scale={0}
                  autoTransform={false}
                >
                  <Center
                    top
                    right
                    ref={door2Ref}
                    {...bindDoor2()}
                    position={[-14, 21, -15]}
                  >
                    <animated.group
                      onClick={(e) => {
                        setClicked({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: true,
                          frame: false,
                        });
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerEnter={(e) => {
                        if (
                          clicked.door2 ||
                          Object.values(clicked).some((value) => value)
                        )
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: true,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerOver={(e) => {
                        if (
                          clicked.door1 ||
                          Object.values(clicked).some((value) => value)
                        )
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: true,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                      onPointerLeave={(e) => {
                        if (Object.values(clicked).some((value) => value))
                          return;
                        setHovered({
                          drawer1: false,
                          drawer2: false,
                          drawer3: false,
                          door1: false,
                          door2: false,
                          frame: false,
                        });
                        e.stopPropagation();
                      }}
                    >
                      <mesh
                        geometry={nodes.Handle_2.geometry}
                        material={goldMat}
                      />
                      <mesh
                        geometry={nodes.Door_2.geometry}
                        material={doorMtl}
                      />

                      <mesh
                        geometry={nodes.Glass_2.geometry}
                        material={glassMAt}
                      />
                    </animated.group>
                  </Center>
                </PivotControls>
              </Select>
              <Select enabled={hovered.drawer2 || clicked.drawer2}>
                <animated.group
                  ref={drawer2Ref}
                  {...bindDrawer2()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer2 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer2 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                >
                  <mesh
                    geometry={nodes.Drawer_2.geometry}
                    material={drawerMtl}
                  />
                  <mesh geometry={nodes.Knobs_2.geometry} material={goldMat} />
                </animated.group>
              </Select>
              <Select enabled={hovered.drawer3 || clicked.drawer3}>
                <animated.group
                  ref={drawer3Ref}
                  {...bindDrawer3()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer3 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer3 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                >
                  <mesh geometry={nodes.Knobs_3.geometry} material={goldMat} />
                  <mesh
                    geometry={nodes.Drawer_3.geometry}
                    material={drawerBigMtl}
                  />
                </animated.group>
              </Select>
              <Select enabled={hovered.drawer1 || clicked.drawer1}>
                <animated.group
                  ref={drawer1Ref}
                  {...bindDrawer1()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      door1: false,
                      door2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                >
                  <mesh
                    geometry={nodes.Drawer_1.geometry}
                    material={drawerMtl}
                  />
                  <mesh geometry={nodes.Knobs_1.geometry} material={goldMat} />
                </animated.group>
              </Select>
            </Select>
          </EffectComposer>
        </Selection>
      </group>
    </animated.group>
  );
});

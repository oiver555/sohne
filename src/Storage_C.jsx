/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 Storage_C.gltf -o C:\Users\osain\Coding\Projects\3js\Sohne\src\Storage_C.jsx 
*/

import React, {
  useContext,
  useEffect,
  useMemo,
  useState,
  useRef,
  useImperativeHandle,
  forwardRef,
} from "react";
import { TransformControls, useGLTF, useTexture } from "@react-three/drei";
import * as THREE from "three";
import { animated, useSpring } from "@react-spring/three";
import { useDrag, useGesture } from "react-use-gesture";
import {
  ExperienceContext,
  GlobalStateContext,
  StorageContext,
} from "./ExpContext";
import {
  EffectComposer,
  Outline,
  Selection,
  Select,
} from "@react-three/postprocessing";
import { KernelSize } from "postprocessing";
import { ArrowStraight } from "./ArrowStraight";
import { ArrowCurved } from "./ArrowCurved";

export default forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF("./gltf/Storage_C.gltf");
   const { storageCRef, storageRotation } = useContext(StorageContext);
  const drawer1Ref = useRef();
  const drawer2Ref = useRef();
  const drawer3Ref = useRef();
  const slide1Ref = useRef();
  const slide2Ref = useRef();
  const { currStorage, setobjConfig, currBaseTexture } =
    useContext(GlobalStateContext);
  const [
    Storage_C_albedo_drawer_1,
    Storage_C_albedo_frame,
    Storage_C_albedo_handle_1,
    Storage_C_albedo_handle_4,
    Storage_C_albedo_innerDrawer_1,
    Storage_C_albedo_shelf_1,
    Storage_C_albedo_slide_1,
    Storage_C_albedo_wheels,
    Storage_C_nor_handle_4,
    Storage_C_rough_drawer_1,
    Storage_C_rough_frame,
    Storage_C_rough_handle_1,
    Storage_C_rough_handle_4,
    Storage_C_rough_innerDrawer_1,
    Storage_C_rough_shelf_1,
    Storage_C_rough_slide_1,
    Storage_C_rough_wheels,
    Storage_C__nor_handle_1,
  ] = useTexture([
    "/textures/Storage_C_albedo_drawer_1.png",
    "/textures/Storage_C_albedo_frame.png",
    "/textures/Storage_C_albedo_handle_1.png",
    "/textures/Storage_C_albedo_handle_4.png",
    "/textures/Storage_C_albedo_innerDrawer_1.png",
    "/textures/Storage_C_albedo_shelf_1.png",
    "/textures/Storage_C_albedo_slide_1.png",
    "/textures/Storage_C_albedo_wheels.png",
    "/textures/Storage_C_nor_handle_4.png",
    "/textures/Storage_C_rough_drawer_1.png",
    "/textures/Storage_C_rough_frame.png",
    "/textures/Storage_C_rough_handle_1.png",
    "/textures/Storage_C_rough_handle_4.png",
    "/textures/Storage_C_rough_innerDrawer_1.png",
    "/textures/Storage_C_rough_shelf_1.png",
    "/textures/Storage_C_rough_slide_1.png",
    "/textures/Storage_C_rough_wheels.png",
    "/textures/Storage_C__nor_handle_1.png",
  ]);
  const [hovered, setHovered] = useState({
    drawer1: false,
    drawer2: false,
    drawer3: false,
    slide1: false,
    slide2: false,
    frame: false,
  });
  const [clicked, setClicked] = useState({
    drawer1: false,
    drawer2: false,
    drawer3: false,
    slide1: false,
    slide2: false,
    frame: false,
  });

  const [spring, set] = useSpring(() => ({
    rotation: [0, 0, 0],
    config: { friction: 10 },
  }));

  const [{ x, y }, api] = useSpring(() => ({ x: 0, y: 0 }));
  const [, frameApi] = useSpring(() => ({ x: 0, y: 0 }));

  const bindStorageC = useDrag(({ down, offset: [mx] }) =>{    
      if (!clicked.frame) return;
      frameApi.start({
        x: down ? (storageCRef.current.rotation.y = mx * 0.01) : 0,
        immediate: down,
      });
  
  });

  const bindDrawer1 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 100 || mx < 0 || !clicked.drawer1) return;
    api.start({
      x: down ? (drawer1Ref.current.position.z = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindDrawer2 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 100 || mx < 0 || !clicked.drawer2) return;
    api.start({
      x: down ? (drawer2Ref.current.position.z = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindDrawer3 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 100 || mx < 0 || !clicked.drawer3) return;
    api.start({
      x: down ? (drawer3Ref.current.position.z = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindSlide1 = useDrag(({ down, offset: [mx] }) => {
    if (mx > 100 || mx < 0 || !clicked.slide1) return;
    api.start({
      x: down ? (slide1Ref.current.position.x = mx * 0.05) : 0,
      immediate: down,
    });
  });
  const bindSlide2 = useDrag(({ down, offset: [mx] }) => {
    console.log(mx);
    if (mx < -150 || mx > 0 || !clicked.slide2) return;
    api.start({
      x: down ? (slide2Ref.current.position.x = mx * 0.05) : 0,
      immediate: down,
    });
  });

  const deSelect = () => {
    console.log("[Storage_C.jsx] deselect()");
    setClicked({
      drawer1: false,
      drawer2: false,
      drawer3: false,
      slide1: false,
      slide2: false,
      frame: false,
    });
    setHovered({
      drawer1: false,
      drawer2: false,
      drawer3: false,
      slide1: false,
      slide2: false,
      frame: false,
    });
  };

  useImperativeHandle(ref, () => {
    return { deSelect };
  });

  Storage_C_albedo_drawer_1.flipY = false;
  Storage_C_albedo_frame.flipY = false;
  Storage_C_albedo_handle_1.flipY = false;
  Storage_C_albedo_handle_4.flipY = false;
  Storage_C_albedo_innerDrawer_1.flipY = false;
  Storage_C_albedo_shelf_1.flipY = false;
  Storage_C_albedo_slide_1.flipY = false;
  Storage_C_albedo_wheels.flipY = false;
  Storage_C_nor_handle_4.flipY = false;
  Storage_C_rough_drawer_1.flipY = false;
  Storage_C_rough_frame.flipY = false;
  Storage_C_rough_handle_1.flipY = false;
  Storage_C_rough_handle_4.flipY = false;
  Storage_C_rough_innerDrawer_1.flipY = false;
  Storage_C_rough_shelf_1.flipY = false;
  Storage_C_rough_slide_1.flipY = false;
  Storage_C_rough_wheels.flipY = false;
  Storage_C__nor_handle_1.flipY = false;
  const drawer1Mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_drawer_1,
    roughnessMap: Storage_C_rough_drawer_1,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const innerDrawer1Mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_innerDrawer_1,
    roughnessMap: Storage_C_rough_innerDrawer_1,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const frameMtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_frame,
    roughnessMap: Storage_C_rough_frame,
    side: THREE.DoubleSide,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const handle1Mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_handle_1,
    roughnessMap: Storage_C_rough_handle_1,
    normalMap: Storage_C__nor_handle_1,
    roughness: 0.4,
    metalness: 0.5,
    envMapIntensity: 0.2,
  });
  const handle4Mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_handle_4,
    roughnessMap: Storage_C_rough_handle_4,
    roughness: 0.4,
    metalness: 0.5,
    envMapIntensity: 0.2,
  });
  const shelfMtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_shelf_1,
    roughnessMap: Storage_C_rough_shelf_1,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const wheels_mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_wheels,
    roughnessMap: Storage_C_rough_wheels,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });
  const slide1Mtl = new THREE.MeshStandardMaterial({
    map: Storage_C_albedo_slide_1,
    roughnessMap: Storage_C_rough_slide_1,
    roughness: 0.4,
    envMapIntensity: 0.2,
  });

  useEffect(() => {
    if (currStorage === "c") {
      setobjConfig({
        baseTextures: [
          "/textures/dark_wood_diff_2k.jpg",
          "/textures/wood_diff_1.jpg",
          "/textures/wood_diff_2.jpg",
        ],
        cushionTextures: [],
      });
    }
  }, [currStorage]);

  return (
    <animated.group
      ref={storageCRef}
      name="Storage_C_grp"
      {...spring}
      {...bindStorageC()}
      position={[19.8, 0, 14]}
      scale={0.65}
      rotation-y={storageRotation.rotate}
      dispose={null}
    >
      <group rotation={[0, 1.6, 0]}>
        <Selection>
          <EffectComposer multisampling={8} autoClear={false}>
            <Outline
              blur
              kernelSize={KernelSize.VERY_SMALL}
              resolutionScale={0}
              visibleEdgeColor={
                Object.values(hovered).some((value) => value)
                  ? "white"
                  : undefined
              }
              edgeStrength={
                Object.values(clicked).some((value) => value) ? 0 : 2
              }
              width={Object.values(hovered).some((value) => value) ? 500 : 0}
            />
            <Outline
              blur
              kernelSize={KernelSize.VERY_SMALL}
              resolutionScale={0}
              visibleEdgeColor={
                Object.values(clicked).some((value) => value)
                  ? "yellow"
                  : undefined
              }
              edgeStrength={
                Object.values(clicked).some((value) => value) ? 2 : 0
              }
              width={Object.values(clicked).some((value) => value) ? 500 : 0}
            />
            <Select enabled={hovered.frame || clicked.frame}>
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Shelf_1_Storage_C.geometry}
                material={shelfMtl}
              />
              <mesh
                castShadow
                receiveShadow
                geometry={nodes.Storage_C_wheels.geometry}
                material={wheels_mtl}
              />

              <mesh
                onClick={(e) => {
                  console.log(e);
                  setClicked({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: false,
                  });
                  e.stopPropagation();
                }}
                onPointerEnter={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  e.stopPropagation();
                }}
                onPointerOver={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: true,
                  });
                  e.stopPropagation();
                }}
                onPointerLeave={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    drawer1: false,
                    drawer2: false,
                    drawer3: false,
                    slide1: false,
                    slide2: false,
                    frame: false,
                  });
                  e.stopPropagation();
                }}
                castShadow
                receiveShadow
                geometry={nodes.Storage_C_Frame.geometry}
                material={frameMtl}
              />

              <Select enabled={hovered.drawer1 || clicked.drawer1}>
                <animated.group
                  ref={drawer1Ref}
                  {...bindDrawer1()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: true,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  name="drawer_1"
                >
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_polySurface14_Drawer_1.geometry}
                    material={handle1Mtl}
                  />
                  <mesh
                    {...bindDrawer1}
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_1_polySurface8.geometry}
                    material={drawer1Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_1_pCube1.geometry}
                    material={innerDrawer1Mtl}
                  />
                </animated.group>
              </Select>
              <Select enabled={hovered.drawer2 || clicked.drawer2}>
                <animated.group
                  ref={drawer2Ref}
                  {...bindDrawer2()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer2 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;

                    setHovered({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer2 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: true,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  name="drawer_2"
                >
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_polySurface10_Drawer_2.geometry}
                    material={handle1Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_2_polySurface7.geometry}
                    material={drawer1Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_2_pCube4.geometry}
                    material={innerDrawer1Mtl}
                  />
                </animated.group>
              </Select>
              <Select enabled={hovered.drawer3 || clicked.drawer3}>
                <animated.group
                  ref={drawer3Ref}
                  {...bindDrawer3()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.drawer3 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.drawer1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: true,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  name="drawer_3"
                >
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_polySurface13_Drawer_3.geometry}
                    material={handle1Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_3_polySurface9.geometry}
                    material={drawer1Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Storage_C_Drawer_3_pCube5.geometry}
                    material={innerDrawer1Mtl}
                  />
                </animated.group>
              </Select>
              <Select enabled={hovered.slide1 || clicked.slide1}>
                <animated.group
                  ref={slide1Ref}
                  {...bindSlide1()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: true,
                      slide2: false,
                      frame: false,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.slide1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: true,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.slide1 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: true,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  name="slide_1"
                >
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.Storage_C_polySurface12_Slide_Drawer_1.geometry
                    }
                    material={handle4Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.Storage_C_Slide_Drawer_1_polySurface6.geometry
                    }
                    material={slide1Mtl}
                  />
                </animated.group>
              </Select>
              <Select enabled={hovered.slide2 || clicked.slide2}>
                <animated.group
                  ref={slide2Ref}
                  {...bindSlide2()}
                  onClick={(e) => {
                    setClicked({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: true,
                    });
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (
                      clicked.slide2 ||
                      Object.values(clicked).some((value) => value)
                    )
                      return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: true,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (
                      clicked.slide2 ||
                      Object.values(clicked).some((value) => value)
                    ) {
                      return;
                    }
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: true,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      drawer1: false,
                      drawer2: false,
                      drawer3: false,
                      slide1: false,
                      slide2: false,
                      frame: false,
                    });
                    e.stopPropagation();
                  }}
                  name="slide_2"
                >
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.Storage_C_polySurface11_Slide_Drawer_2.geometry
                    }
                    material={handle4Mtl}
                  />
                  <mesh
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.Storage_C_Slide_Drawer_2_polySurface5.geometry
                    }
                    material={slide1Mtl}
                  />
                </animated.group>
              </Select>
            </Select>
          </EffectComposer>
        </Selection>
      </group>
    </animated.group>
  );
});

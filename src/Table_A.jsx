/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 C:\Users\osain\Coding\Projects\3js\Sohne\Maya\scenes\Table_A.gltf -o C:\Users\osain\Coding\Projects\3js\Sohne\src\Table_A.jsx 
*/

import React, {
  useContext,
  useEffect,
  useMemo,
  useState,
  useRef,
  useImperativeHandle,
} from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import * as THREE from "three";
import { animated, useSpring } from "@react-spring/three";
import { useDrag, useGesture } from "react-use-gesture";
import {
  ExperienceContext,
  GlobalStateContext,
  TablesContext,
} from "./ExpContext";
import {
  EffectComposer,
  Outline,
  Selection,
  Select,
} from "@react-three/postprocessing";
import { KernelSize } from "postprocessing";
import useConstant from "./hooks/useConstant";
import { useThree } from "@react-three/fiber";
export const Table_A = React.forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF("./gltf/Table_A.gltf");
  const { logFloat32Array } = useConstant();
  const { size, viewport } = useThree();
  const aspect = size.width / viewport.width;

  // console.log(size.width, viewport.width);
  const [
    mahBase,
    mahHead,
    oakBase,
    oakHead,
    aoBase,
    aoHead,
    roughBase,
    roughHead,
  ] = useTexture([
    "/textures/Table_A_albedo_mahogany_base.png",
    "/textures/Table_A_albedo_mahogany_head.png",
    "/textures/Table_A_albedo_oak_base.png",
    "/textures/Table_A_albedo_oak_head.png",
    "/textures/Table_A_AO_base.png",
    "/textures/Table_A_AO_head.png",
    "/textures/Table_A_rough_mahogany_base.png",
    "/textures/Table_A_rough_mahogany_head.png",
  ]);
  const baseMat = new THREE.MeshStandardMaterial({
    map: mahBase,
    aoMap: aoBase,
    aoMapIntensity: 1,
    envMapIntensity: 0.2,
    roughnessMap: roughBase,
    roughness: 0.5,
  });
  const headMat = new THREE.MeshStandardMaterial({
    map: mahHead,
    aoMap: aoHead,
    aoMapIntensity: 1,
    envMapIntensity: 0.2,
    roughnessMap: roughBase,
    roughness: 0.5,
  });
  const baseMatOpa = new THREE.MeshStandardMaterial({
    map: mahBase,
    aoMap: aoBase,
    aoMapIntensity: 1,
    envMapIntensity: 0.2,
    roughnessMap: roughBase,
    roughness: 0.5,
    opacity: 0.5,
    transparent: true,
  });
  const headMatOpa = new THREE.MeshStandardMaterial({
    map: mahHead,
    aoMap: aoHead,
    aoMapIntensity: 1,
    envMapIntensity: 0.2,
    roughnessMap: roughBase,
    roughness: 0.5,
    opacity: 0.5,
    transparent: true,
  });

  mahBase.flipY = false;
  mahHead.flipY = false;
  oakBase.flipY = false;
  oakHead.flipY = false;
  aoBase.flipY = false;
  aoHead.flipY = false;
  roughBase.flipY = false;
  roughHead.flipY = false;
  const table1Ref = useRef();
  const head1Ref = useRef();
  const [hovered, setHovered] = useState({
    base1: false,
    head1: false,
    base2: false,
    head2: false,
    base3: false,
    head3: false,
  });
  const [clicked, setClicked] = useState({
    base1: false,
    head1: false,
    base2: false,
    head2: false,
    base3: false,
    head3: false,
  });

  const constrainBaseToHeadPlus = (distance) => {
    const positionAttribute = nodes.table_A_Base_1.geometry.attributes.position;
    const positions = positionAttribute.array;

    for (let i = 0; i < positions.length; i += 3) {
      const y = positions[i + 1]; // Get the Y coordinate of the vertex
      if (y > 30 && positions[i + 1] + distance * 0.265 > 30) {
        positions[i + 1] += distance * 0.265;
      }
    }
    positionAttribute.needsUpdate = true;
    nodes.table_A_Base_1.geometry.computeBoundingSphere();
  };

  const constrainBaseToHeadMinus = (distance) => {
    const positionAttribute = nodes.table_A_Base_1.geometry.attributes.position;
    const positions = positionAttribute.array;
    for (let i = 0; i < positions.length; i += 3) {
      const y = positions[i + 1]; // Get the Y coordinate of the vertex

      if (y > 30 && positions[i + 1] + distance * 0.265 > 30) {
        positions[i + 1] -= distance * 0.265;
      }
    }
    positionAttribute.needsUpdate = true;
    nodes.table_A_Base_1.geometry.computeBoundingSphere();
  };

  const [springBase1, setBase1Spring] = useSpring(() => ({
    position: [0, 0, 0],
    config: { friction: 10 },
  }));
  const bindBase1 = useDrag(({ down, offset: [mx, my] }) => {
    if (!clicked.base1) return;
    setBase1Spring({
      position: [my * 0.8, 0, -mx * 0.4 + my * 0.6],
      immediate: down,
    });
  });
  const [springHead1, setHead1Spring] = useSpring(() => ({
    position: [0, 0, 0],
    config: { friction: 10 },
  }));
  const bindHead1 = useDrag(
    ({
      down,
      direction: [dx, dy],
      delta: [deltaX, deltaY],
      offset: [mx, my],
    }) => {
      if (!clicked.head1) return;
      setHead1Spring({ position: [0, -my * 0.25, 0], immediate: down });

      // console.log(dy);
      if (dy < 0) {
        constrainBaseToHeadPlus(-deltaY);
      } else if (dy > 0.1) {
        console.log("minus");
        constrainBaseToHeadMinus(deltaY);
      }
    }
  );
  const { tableRotation, tableARef } = useContext(TablesContext);
  const { currChair, setobjConfig, currBaseTexture } =
    useContext(GlobalStateContext);

  const deSelect = () => {
    console.log("[Table_A.jsx] deselect()");
    setClicked({
      base1: false,
      head1: false,
      base2: false,
      head2: false,
      base3: false,
      head3: false,
    });
    setHovered({
      base1: false,
      head1: false,
      base2: false,
      head2: false,
      base3: false,
      head3: false,
    });
  };

  useImperativeHandle(ref, () => {
    return { deSelect };
  });

  return (
    <animated.group
      {...props}
      ref={tableARef}
      dispose={null}
      scale={0.1}
      position={[20, -0, 15]}
      rotation-y={tableRotation.rotate}
    >
      <Selection>
        <EffectComposer multisampling={8} autoClear={false}>
          <Outline
            blur
            kernelSize={KernelSize.VERY_SMALL}
            resolutionScale={0}
            visibleEdgeColor={"white"}
            edgeStrength={2}
            width={Object.values(hovered).some((value) => value) ? 500 : 0}
          />
          <Outline
            blur
            kernelSize={KernelSize.VERY_SMALL}
            resolutionScale={0}
            visibleEdgeColor={"yellow"}
            edgeStrength={2}
            width={Object.values(clicked).some((value) => value) ? 500 : 0}
          />
          <Select enabled={hovered.base1 || clicked.base1}>
            <animated.group {...bindBase1()} {...springBase1}>
              <Select enabled={hovered.head1 || clicked.head1}>
                <animated.group {...bindHead1()} {...springHead1}>
                  <mesh
                    onClick={(e) => {
                      setClicked({
                        base1: false,
                        head1: true,
                        base2: false,
                        head2: false,
                        base3: false,
                        head3: false,
                      });
                      setHovered({
                        base1: false,
                        head1: true,
                        base2: false,
                        head2: false,
                        base3: false,
                        head3: false,
                      });
                      e.stopPropagation();
                    }}
                    onPointerEnter={(e) => {
                      if (Object.values(clicked).some((value) => value)) return;
                      setHovered({
                        base1: false,
                        head1: true,
                        base2: false,
                        head2: false,
                        base3: false,
                        head3: false,
                      });
                      e.stopPropagation();
                    }}
                    onPointerOver={(e) => {
                      if (Object.values(clicked).some((value) => value)) return;
                      setHovered({
                        base1: false,
                        head1: true,
                        base2: false,
                        head2: false,
                        base3: false,
                        head3: false,
                      });
                      e.stopPropagation();
                    }}
                    onPointerLeave={(e) => {
                      if (Object.values(clicked).some((value) => value)) return;
                      setHovered({
                        base1: false,
                        head1: false,
                        base2: false,
                        head2: false,
                        base3: false,
                        head3: false,
                      });
                      e.stopPropagation();
                    }}
                    castShadow
                    receiveShadow
                    geometry={nodes.table_A_Head_1.geometry}
                    material={
                      clicked.head1 || clicked.base1
                        ? headMat
                        : Object.values(clicked).some((value) => value)
                        ? headMatOpa
                        : headMat
                    }
                  />
                </animated.group>
              </Select>
              <mesh
                onClick={(e) => {
                  const positionAttribute =
                    nodes.table_A_Base_1.geometry.attributes.position;
                  const normalAttribute =
                    nodes.table_A_Base_1.geometry.attributes.normal;
                  const positions = positionAttribute.array;
                  const normals = normalAttribute.array;
                  const moveDistance = 0.1; // Distance to move along the normal (adjust as needed)

                  // for (let i = 0; i < positions.length; i += 3) {
                  //   const x = positions[i]; // Get the X coordinate of the vertex
                  //   const y = positions[i + 1]; // Get the Y coordinate of the vertex
                  //   const z = positions[i + 2]; // Get the Z coordinate of the vertex

                  //   const nx = normals[i];
                  //   const ny = normals[i + 1];
                  //   const nz = normals[i + 2];

                  //   console.log(y);
                  //   if (y < 2) {
                  //     console.log(nx);
                  //     positions[i] += nx * moveDistance;
                  //     // positions[i + 1] += ny * moveDistance;
                  //     positions[i + 2] += nz * moveDistance;
                  //   }
                  // }
                  // positionAttribute.needsUpdate = true;
                  // nodes.table_A_Base_1.geometry.computeBoundingSphere();

                  setClicked({
                    base1: true,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  setHovered({
                    base1: true,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerEnter={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: true,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerOver={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: true,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerLeave={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                castShadow
                receiveShadow
                geometry={nodes.table_A_Base_1.geometry}
                material={
                  clicked.head1 || clicked.base1
                    ? baseMat
                    : Object.values(clicked).some((value) => value)
                    ? baseMatOpa
                    : baseMat
                }
              />
            </animated.group>
          </Select>
          <Select enabled={hovered.base2 || clicked.base2}>
            <group>
              <Select enabled={hovered.head2 || clicked.head2}>
                <mesh
                  onClick={(e) => {
                    setClicked({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: true,
                      base3: false,
                      head3: false,
                    });
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: true,
                      base3: false,
                      head3: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: true,
                      base3: false,
                      head3: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: true,
                      base3: false,
                      head3: false,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: false,
                    });
                    e.stopPropagation();
                  }}
                  castShadow
                  receiveShadow
                  geometry={nodes.table_A_Head_2.geometry}
                  material={
                    clicked.head2 || clicked.base2
                      ? headMat
                      : Object.values(clicked).some((value) => value)
                      ? headMatOpa
                      : headMat
                  }
                />
              </Select>
              <mesh
                onClick={(e) => {
                  setClicked({
                    base1: false,
                    2: false,
                    base2: true,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: true,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerEnter={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: true,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerOver={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: true,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerLeave={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                castShadow
                receiveShadow
                geometry={nodes.table_A_Base_2.geometry}
                material={
                  clicked.head2 || clicked.base2
                    ? baseMat
                    : Object.values(clicked).some((value) => value)
                    ? baseMatOpa
                    : baseMat
                }
              />
            </group>
          </Select>
          <Select enabled={hovered.base3 || clicked.base3}>
            <group>
              <Select enabled={hovered.head3 || clicked.head3}>
                <mesh
                  onClick={(e) => {
                    setClicked({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: true,
                    });
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: true,
                    });
                    e.stopPropagation();
                  }}
                  onPointerEnter={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: true,
                    });
                    e.stopPropagation();
                  }}
                  onPointerOver={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: true,
                    });
                    e.stopPropagation();
                  }}
                  onPointerLeave={(e) => {
                    if (Object.values(clicked).some((value) => value)) return;
                    setHovered({
                      base1: false,
                      head1: false,
                      base2: false,
                      head2: false,
                      base3: false,
                      head3: false,
                    });
                    e.stopPropagation();
                  }}
                  castShadow
                  receiveShadow
                  geometry={nodes.table_A_Head_3.geometry}
                  material={
                    clicked.head3 || clicked.base3
                      ? headMat
                      : Object.values(clicked).some((value) => value)
                      ? headMatOpa
                      : headMat
                  }
                />
              </Select>
              <mesh
                onClick={(e) => {
                  setClicked({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: true,
                    head3: false,
                  });
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: true,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerEnter={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: true,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerOver={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: true,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                onPointerLeave={(e) => {
                  if (Object.values(clicked).some((value) => value)) return;
                  setHovered({
                    base1: false,
                    head1: false,
                    base2: false,
                    head2: false,
                    base3: false,
                    head3: false,
                  });
                  e.stopPropagation();
                }}
                castShadow
                receiveShadow
                geometry={nodes.table_A_Base_3.geometry}
                material={
                  clicked.head3 || clicked.base3
                    ? baseMat
                    : Object.values(clicked).some((value) => value)
                    ? baseMatOpa
                    : baseMat
                }
              />
            </group>
          </Select>
        </EffectComposer>
      </Selection>
    </animated.group>
  );
});
